---
layout: post
title: "A comparison of tools for calling CNVs from sequence data"
author: ericminikel
date: 2014-01-17 13:10:10
---
<p>I&#8217;m still getting oriented in my new job at <a href="http://www.macarthurlab.org/">Daniel MacArthur&#8217;s lab</a>, and I&#8217;m learning that one of the lab&#8217;s priorities over the next couple of months will be to improve the way we handle <a href="http://en.wikipedia.org/wiki/Copy-number_variation">copy number variations</a> (CNVs) in our pipeline for identifying mutations that cause rare Mendelian diseases.  We have whole exome (or, in a few cases, whole genome) next generation sequencing (NGS) data for patients and we are exploring using some combination of three different tools for calling CNVs from these NGS data.  The three tools in question are <a href="http://cran.r-project.org/web/packages/ExomeDepth/ExomeDepth.pdf">ExomeDepth</a> [<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3476336/">Plagnol 2012</a>] and <a href="https://atgu.mgh.harvard.edu/xhmm/">XHMM</a> [<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3484655/">Fromer 2012</a>] for exomes and <a href="http://www.broadinstitute.org/software/genomestrip/">GenomeSTRiP</a> [<a href="http://www.ncbi.nlm.nih.gov/pubmed/21317889">Handsaker 2011</a>] for whole genomes. (Note: there are certainly other tools out there as well &#8211; see <a href="http://www.biostars.org/p/13807/">this Biostars discussion</a> &#8211; but these are the ones we&#8217;re focusing on here).</p>
<p>In this post I plan to familiarize myself with the three tools in a few different ways:</p>
<ul>
<li>the big picture concepts of how they call CNVs and their relative strengths and weaknesses</li>
<li>how to run them</li>
<li>how their output is structured</li>
<li>how they convey confidence and uncertainty in output</li>
</ul>
<p><strong><a href="http://cran.r-project.org/web/packages/ExomeDepth/ExomeDepth.pdf">ExomeDepth</a><br/>
</strong></p>
<p>The paper introducing ExomeDepth [<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3476336/">Plagnol 2012</a>] begins with a nice introduction to CNV calling generally, and defines three distinct approaches to detecting CNVs (or, more broadly, any structural variations) in NGS data:</p>
<ol>
<li><strong>split reads</strong> &#8211; Look for individual reads that span a deletion or insertion breakpoint</li>
<li><strong>read pairs</strong> &#8211; Look for read pairs that map to an improbable distance apart (for deletions) or even to different contigs (for structural variations)</li>
<li><strong>read depth</strong> &#8211; Look for regions that have too much or too little read depth compared to a reference sample.</li>
</ol>
<p>Plagnol quickly makes the argument that approaches 1 and 2 are of limited utility in exome sequencing since they&#8217;ll only detect breakpoints that happen to fall right within an exon. ExomeDepth is, therefore, based on approach 3.</p>
<p>Read depth depends on many factors besides copy number &#8211; alignability, GC content, exome capture efficiency, etc.  See my adventures with the <a title="PRNP deletions in 1000 Genomes are not real" href="/2013/03/31/prnp-deletions-in-1000-genomes-are-not-real/">PRNP deletions in 1000 Genomes</a> for an example of a false positive CNV call due to GC content.  To minimize mistakes like those, read depth should be considered not in absolute terms but relative to a reference sample (say, an average of many other exomes). Other tools were already doing this before ExomeDepth came along, but Plagnol&#8217;s main objection to those tools was their assumption that relative read depth should be <em>normally</em> distributed around expectation.  Plagnol presents data to refute this assumption and argues for a more complex model based on a beta-binomial model.</p>
<p>ExomeDepth has another clever trick as well, in how it creates a reference sample. Many of the factors I mentioned above &#8211; say, GC bias and capture efficiency bias &#8211; vary from library prep to library prep, meaning that the best reference sample to compare your test sample to is one which was prepared in the <em>exact same way</em>.  That&#8217;s hard to achieve.  ExomeDepth tries to get as close to this goal as possible by iterating over the samples and progressively selecting as references those individual samples which have the highest correlation (in depth across all exons) with the test sample. So if you&#8217;re interested in sample 1, then maybe ExomeDepth will make a reference by averaging sample 9 (r = .99 with sample 1), sample 15 (r = .98), sample 19 (r = .96) and so on, while leaving out sample 2 (r = .87), sample 3 (r = .92), etc. The more samples you add, the lower the variance (since you&#8217;re averaging away any <em>real</em> CNVs as well as chance variation in the reference set), but the higher the bias (since you&#8217;re adding samples which are less correlated with the test sample). The optimal tradeoff between these countervailing factors seems to occur when using the average of the top 10 or so most correlated samples as a reference.</p>
<p>Even still, ExomeDepth&#8217;s power depends massively on just how good the best correlated reference samples are. If there&#8217;s a lot of technical variability and only poorly correlated reference samples are available, then no amount of read depth will give you adequate power. This point was argued again in <a href="http://plagnol-lab.blogspot.com/2013/11/faq-and-clarifications-for-exomedepth-r.html">a blog post from the Plagnol lab</a>.</p>
<p>In terms of strengths and weaknesses, ExomeDepth is really at its shining best when you have a number of highly correlated samples &#8211; i.e. samples prepared in almost exactly the same way.  As pointed out in the <a href="http://cran.r-project.org/web/packages/ExomeDepth/vignettes/ExomeDepth-vignette.pdf">vignette</a>, those samples also need to <em>not</em> have the CNV you&#8217;re interested in, which means that you need unrelated samples and you&#8217;re best off if you&#8217;re looking for rare CNVs (e.g. in Mendelian disorders) rather than common CNVs.</p>
<p>ExomeDepth is implemented as <a href="http://cran.r-project.org/web/packages/ExomeDepth/ExomeDepth.pdf">an R package</a> with <a href="http://cran.r-project.org/web/packages/ExomeDepth/vignettes/ExomeDepth-vignette.pdf">a handy vignette</a>. For input, you need BAMs aligned to hg19, sorted and index. ExomeDepth will take it from there &#8211; calculating depth for each exon, selecting a reference set and calling CNVs.  I&#8217;ve got a simple R script to run ExomeDepth up and running <a href="https://github.com/ericminikel/ngs-scripts/blob/master/runExomeDepth.r">here</a>. By way of exposition, the two basic steps are as follows.  First, pass a vector of BAM path strings to <code>getBamCounts</code> to get counts per sample per exon:</p>
<pre class="brush: r; title: ; notranslate" title="">
counts = getBamCounts(bed.frame = exons.hg19, bam.files = bams)
</pre>
<p>Here&#8217;s an easy thing to get tripped up on: when you first read that list of BAMs in from disk, it is *essential* that you have set <code>options(stringsAsFactors=FALSE)</code> so that the <code>getBamCounts</code> function sees strings, not factors.</p>
<p>Next, iterate over the samples you want to call CNVs on, and for each one, find the best reference set and then call CNVs against those. Note that (as far as I can tell) you end up needing three copies of the counts: one as its native S4 object, one as a data frame and one as a matrix. Let me know if you have a way to avoid this.</p>
<pre class="brush: r; title: ; notranslate" title="">
countdf = as.data.frame(counts)
countmat = as.matrix(countdf[,6:dim(countdf)[2]]) # remove cols 1-5 metadata

for (i in 1:dim(countmat)[2]) {
    sample_name = colnames(countmat)[i]
    reference_list = select.reference.set(test.counts = countmat[,i],
        reference.count = countmat[,-i],
        bin.length=(countdf$end-countdf$start)/1000,
        n.bins.reduced = 10000)
    reference_set = apply(
        X = as.matrix(countdf[, reference_list$reference.choice]),
        MAR=1, FUN=sum)
    all_exons = new('ExomeDepth', test=countmat[,i],
        reference=reference_set,
        formula = 'cbind(test,reference) ~ 1')
    all_exons = CallCNVs(x = all_exons, transition.probability=10^-4,
        chromosome=countdf$space, start=countdf$start,
        end=countdf$end, name=countdf$names)
    write.table(all_exons@CNV.calls, file=paste(sample_name,&quot;.txt&quot;,sep=''),
        sep='\t', row.names=FALSE, col.names=TRUE, quote=FALSE)
    if (opt$verbose) {
        cat(paste(&quot;Wrote CNV calls for &quot;,sample_name,&quot;\n&quot;,sep=''),file=stdout())
    }
}
</pre>
<p>The output for each sample will look like this (formatted with <code>cat samplename.bam.txt | column -t</code>):</p>
<pre>start.p  end.p   type         nexons  start     end       chromosome  id                       BF    reads.expected  reads.observed  reads.ratio
231958   231958  deletion     1       16287256  16287718  22          chr22:16287256-16287718  38.1  223             0               0
232036   232037  deletion     2       17061818  17062178  22          chr22:17061818-17062178  5.55  205             123             0.6
232070   232070  duplication  1       17177670  17179047  22          chr22:17177670-17179047  5.71  61              124             2.03</pre>
<p>The CNVs are identified by genomic coordinates. There&#8217;s also an option to annotate them with IDs from <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3330748/">Conrad 2010</a> (a paper with some validated CNVs) and exon IDs, but this is in beta.</p>
<p>The output includes a BF column, for Bayes Factor. In theory this the log10 likelihood ratio of the alternative hypothesis (yes there&#8217;s a CNV) over the null hypothesis (no CNV here) — so in the first row above, the CNV is 10<sup>38</sup> more likely than no CNV — though the <a href="http://cran.r-project.org/web/packages/ExomeDepth/vignettes/ExomeDepth-vignette.pdf">vignette</a> acknowledges these may sometimes be &#8220;unconvincing&#8221;.  ExomeDepth describes itself as being &#8220;aggressive&#8221; [see <a href="http://cran.r-project.org/web/packages/ExomeDepth/vignettes/ExomeDepth-vignette.pdf">vignette</a>] &#8211; i.e. it favors sensitivity in its CNV calls, and if you want specificity instead, the Bayes Factor is there for you.</p>
<p>In terms of runtime, for a toy example to get started with I subsetted out only chromosome 22 from 20 BAMs, computed counts and called CNVs on all of them. This tiny task took 38 minutes in total. Note that I did the CNV calling in serial, whereas you could easily save off the counts to an <code>.rda</code> file and then parallelize the CNV calling part.</p>
<p><a href="https://atgu.mgh.harvard.edu/xhmm/"><strong>XHMM</strong></a></p>
<p>Like ExomeDepth, XHMM [<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3484655/">Fromer 2012</a>, see also <a href="http://www.broadinstitute.org/gatk//events/2038/GATKwh0-Z2-XHMM_tutorial-Fromer.pdf">this presentation</a>] relies on read depth as the sole source of information on CNV events, ignoring split read and read pair information. But whereas ExomeDepth creates an optimized reference sample set to handle all the sources of inter-exon variability, XHMM uses principal components to handle normalization. In particular, it creates a matrix of the depth of all exons in all samples, and the principal components of this matrix are expected to capture many of the non-CNV factors that affect an exon&#8217;s read depth.</p>
<p>Once normalization is done and XHMM gets around to calling CNVs, it does something clever, as you may have guessed from the name, which stands for exome <a href="http://en.wikipedia.org/wiki/Hidden_Markov_model">hidden Markov model</a>.  Whereas ExomeDepth considers every exon as being completely independent of every other exon, XHMM takes advantage of the fact that (sufficiently large) CNVs will affect a whole contiguous swath of exons. In other words, if exon 1 is deleted, then the prior probability for exon 2 being deleted is considerably higher than if no CNV had yet been detected in the gene.  Hidden Markov models rely on probabilities of transitions between states (e.g. from the &#8220;no CNV&#8221; state to the &#8220;yes CNV&#8221; state and back again), and the XHMM needs just two quantities from which to base all of its probabilities.  p is the rate of exonic CNVs, and q is the reciprocal of the average CNV length (number of exons).  According to <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3484655/table/tbl1/">Table 1</a>, the model assumed is this:</p>
<p><a href="/wp-content/uploads/2014/01/xhmm-model.png"><img class="alignnone size-full wp-image-3505" alt="xhmm-model" src="/wp-content/uploads/2014/01/xhmm-model.png"/></a></p>
<p>Like ExomeDepth, XHMM is tuned to detect rare CNVs, whereas common CNVs may go undetected since they are present in the reference samples used for PCA.  Also like ExomeDepth, XHMM favors sensitivity over specificity in its calling process, giving you a long list of possible CNVs along with quality scores so that you can filter as you wish. The quality scores are the posterior probabilities for each CNV <a href="http://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm">as per HMM theory</a>.</p>
<p>XHMM was developed by the folks at Broad, and accordingly it is built around <a href="http://www.broadinstitute.org/gatk/">GATK</a> &#8211; the user is expected to first run GATK&#8217;s <a href="http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_coverage_DepthOfCoverage.html">DepthOfCoverage</a> function to get exon read depths. Like GATK, XHMM is non-trivial to use. The authors have provided a 70-minute YouTube tutorial:</p>
<p><iframe src="//www.youtube.com/embed/_bc7Gg5moYM" height="315" width="560" allowfullscreen="" frameborder="0"></iframe></p>
<p>My most basic pipeline to run XHMM right now is <a href="https://github.com/ericminikel/ngs-scripts/blob/master/runXHMM.bash">this bash script</a>. My goal with it was just to see what it would take to get XHMM to run <em>at all</em>; there&#8217;s nothing good or interesting about the way I&#8217;m running it and I&#8217;m not using any of the fancy options.  It&#8217;s basically a very lightly modified version of some <code>getopts</code> code to accept command line args from <a href="http://stackoverflow.com/a/14203146">this StackOverflow post</a> and the example code from the <a href="https://atgu.mgh.harvard.edu/xhmm/tutorial.shtml">XHMM tutorial</a>.  One trivial but useful point: your BAM list <em>must</em> have a name that ends in <code>.list</code>.</p>
<p>As you can see from that bash script, it takes a lot more code to run XHMM than to run ExomeDepth. Once you do, the outputs are two.  You get a VCF file with the CNV boundaries as the <code>ID</code> field, &lt;DIP&gt; (for diploid) as the <code>REF</code> field, and &lt;DEL&gt;,&lt;DUP&gt; (for deleted/duplicated) as the <code>ALT</code> field, like so:</p>
<pre>
#CHROM  POS       ID                    REF    ALT          QUAL  FILTER  INFO
22      23029456  22:23029456-23241835  &lt;DIP&gt;  &lt;DEL&gt;,&lt;DUP&gt;  .     .       AC=1,0...
22      23077281  22:23077281-23165783  &lt;DIP&gt;  &lt;DEL&gt;,&lt;DUP&gt;  .     .       AC=3,1...
22      23077281  22:23077281-23223572  &lt;DIP&gt;  &lt;DEL&gt;,&lt;DUP&gt;  .     .       AC=3,0...
</pre>
<p>And you also get a <code>.xcnv</code> file where each row is one sample-CNV combination, with all manner of quality scores included as columns for your filtering pleasure:</p>
<pre>
SAMPLE      CNV  INTERVAL              KB      CHR  MID_BP    TARGETS     NUM_TARG  Q_EXACT  Q_SOME  Q_NON_DIPLOID  Q_START  Q_STOP  MEAN_RD  MEAN_ORIG_RD
sample1     DEL  22:23077281-23247205  169.93  22   23162243  579..594    16        25       99      99             33       12      -3.52    38.07
sample2     DEL  22:39378457-39388452  10.00   22   39383454  2097..2104  8         3        99      99             3        3       -3.88    30.50
sample3     DEL  22:23029456-23241835  212.38  22   23135645  574..592    19        10       99      99             16       9       -3.77    28.84
sample4     DUP  22:23077281-23165783  88.50   22   23121532  579..587    9         21       71      71             23       17      2.90     89.04
</pre>
<p><a href="http://www.broadinstitute.org/software/genomestrip/"><strong>GenomeSTRiP</strong></a></p>
<p>The (sadly paywalled) GenomeSTRiP paper [<a href="http://www.ncbi.nlm.nih.gov/pubmed/21317889">Handsaker 2011</a>] provides an almost narrative walk-through of the logic that went into designing it. Unlike the exome-based callers above, GenomeSTRiP utilizes all three possible sources of CNV information: read pairs, split reads, and read depth.</p>
<p>The paper goes into the greatest detail on how aberrant read pairs &#8211; those which map too far apart, suggesting a deletion in between them &#8211; are utilized. To maximize statistical power, it uses three concepts which the authors introduce as <em>coherence</em>, <em>heterogeneity</em>, and <em>allelic substitution</em>.</p>
<ul>
<li><em>coherence</em> means that the statistical case for a CNV is based on cumulative evidence from many read pairs in many genomes. While chimeric molecules generated in the sequencing process should be dispersed across the genome, read pairs representing true CNV breakpoints should be clustered in one place. Moreover, in high-n-but-low-coverage sequencing projects like 1000 Genomes, aberrant read pairs for not-too-rare CNVs should be found in many different genomes, so you get more power from populaton-based (rather than individual) CNV calling.  (However, it is noted that GenomeSTRiP still <em>can</em> call CNVs private to one individual).</li>
<li><em>heterogeneity</em> means that if the CNV is real, then some genomes have it and others don&#8217;t, and those cases should look different. 1 aberrant read pair in each of 50 genomes looks like noise; 50 aberrant read pairs in 1 genome looks real.  GenomeSTRiP applies a chi squared test of independence to determine whether aberrant read pairs at a particular site occur equally in all genomes or are clustered in a few genomes.</li>
<li><em>allelic substitution</em> means that if Haplotype A contains a deletion and Haplotype B doesn&#8217;t, then across genomes, the abundance of reads supporting Hap A should be inversely correlated with the abundance of reads supporting Hap B.</li>
</ul>
<p><a href="http://www.broadinstitute.org/software/genomestrip/sites/default/files/materials/GATKWorkshop_GenomeSTRiP_tutorial_July2013.pdf">This tutorial</a> helped me to understand that GenomeSTRiP actually operates in a few distinct phases: discovery, refinement and genotyping.</p>
<ul>
<li><strong>discovery</strong>. The above-described tricks, based on read pairs, are all used to discover CNVs in a population of samples. As a validation of sorts, the average read depth over the putative CNV site is then compared between samples <em>with</em> aberrant read pairs and those <em>without.  </em>Proposed CNVs are written to a library file.</li>
<li><strong>refinement</strong>. The proposed CNVs from the genotyping stage are validated by <em>de novo</em> assembly of nearby (and/or unmapped) reads to see if any turn out to be split reads spanning a breakpoint.  Unfortunately, GenomeSTRiP doesn&#8217;t quite do this all for you. They recommend using a third-party tool (<a href="http://gmt.genome.wustl.edu/tigra-sv/current/">TIGRA-SV</a> [<a href="http://www.ncbi.nlm.nih.gov/pubmed/24307552">Chen 2014</a>] or <a href="http://sv.gersteinlab.org/age/">AGE</a> [<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3042181/">Abyzov &amp; Gerstein 2011</a>]) to discover the exact alternate alleles and get a VCF, and then GenomeSTRiP will use that VCF and your BAMs to re-align reads from your samples to the proposed alternate alleles.</li>
<li><strong>genotyping</strong>. Each sample is tested for evidence &#8211; from read pairs, split reads and read depth &#8211; of the validated CNV haplotypes from the refinement stage.</li>
</ul>
<p>Reading through the tutorial, it strikes me that many of the parameters used by GenomeSTRiP under default settings are chosen for low-depth, high-n studies like 1000 Genomes. For instance, the default threshold for discovery is a minimum of 1.1 aberrant read pairs per proposed affected samples [<a href="http://www.broadinstitute.org/software/genomestrip/sites/default/files/materials/GATKWorkshop_GenomeSTRiP_tutorial_July2013.pdf">tutorial</a>].  If you&#8217;ve got decent depth, you can afford to set a much higher threshold than that, and if you&#8217;ve got low n, you need to.</p>
<p>Towards the end of the <a href="http://www.broadinstitute.org/software/genomestrip/sites/default/files/materials/GATKWorkshop_GenomeSTRiP_tutorial_July2013.pdf">tutorial</a> there is more discussion of how to apply GenomeSTRiP to Mendelian families with low n. In general, GenomeSTRiP is said to &#8220;Need 20-30+ samples for good results&#8221;, and calling variants in a single deeply sequenced individual is still a &#8220;Future goal.&#8221; But if you do manage to call some variants in a small family with a rare Mendelian disease, one nice facility that GenomeSTRiP provides is the ability to check for the presence of your variant in the 1000 Genomes BAM, to confirm its rareness.</p>
<p>GenomeSTRiP is by far the most complex of the three tools described here, and accordingly its operation has so far eluded me altogether.  The <a href="http://gatkforums.broadinstitute.org/discussion/1534/genomestrip-main-page">official documentation</a> provides four separate Queue scripts for running the various steps of GenomeSTRiP; the <a href="http://www.broadinstitute.org/software/genomestrip/node/34">cookbook</a> only has examples of the (comparatively) simple task of genotyping a known site in 1000 Genomes.  My <a href="/2012/09/19/exome-sequencing-pipeline-using-gatk/" title="Exome sequencing pipeline using GATK">past experience with Queue</a> tells me it would probably take me tens of hours to get competent at using GenomeSTRiP &#8211; this is the kind of investment that shouldn&#8217;t be duplicated, so I&#8217;m going to hold off for bigger plan on how we&#8217;ll run GenomeSTRiP before diving into it myself.</p>
<p><strong>how to use all three tools?</strong></p>
<p>Say we have &#8211; best case scenario &#8211; both exome and whole genome data on some samples, and we want to run all three tools. They are each looking at sources of information that are at least partly orthogonal, so they each could bring valuable information to the search for a causal CNV in a patient.  Our current thinking is not to try to do any meta-analysis of the three outputs, but rather to just list (say, for each exon) whether each tool called a CNV, and with what quality/probabilty, etc.</p>
